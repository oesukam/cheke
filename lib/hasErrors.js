const validators=require("./validators"),notAllowedMessage=require("./messages/notAllowedMessage"),valids=Object.keys(validators),hasErrors=({data:c={},reqRules:a,path:b}={})=>new Promise((d,e)=>{a||d(!1);const f={...c,...a};Object.keys(f).forEach(f=>{a[f]===void 0&&d({[f]:{path:b,message:notAllowedMessage(f)}}),a[f]||a[f]===void 0||e(Error(`${f}'s rule can not be empty`));const g=a[f].split("|").map(a=>a.trim());Object.keys(g).forEach(a=>{const[e,h]=g[a].split(":");-1===valids.indexOf(e)&&d({[f]:{path:b,message:`${e} rule does not exist`}}),c[f]||-1===g.indexOf("required")||d({[f]:{path:b,message:validators.required({value:c[f],label:f})}});const i=validators[e]({value:c[f],label:f,valid:h,path:b});i&&d({[f]:{path:b,message:i}})})}),d(!1)});module.exports=hasErrors;