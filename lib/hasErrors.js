const validators=require("./validators"),notAllowedMessage=require("./messages/notAllowedMessage"),{getRules}=require("./helpers"),valids=Object.keys(validators),hasErrors=({data:c={},reqRules:a,path:b}={})=>new Promise((d,e)=>{a||d(!1);const f={...c,...a};Object.keys(f).forEach(f=>{(a[f]===void 0||"object"==typeof a[f]&&a[f].type===void 0)&&d({[f]:{path:b,message:notAllowedMessage(f)}}),a[f]&&("object"!=typeof a[f]||a[f].type)||e(Error(`${f}'s rule can not be empty`));const g=getRules(a[f]);Object.keys(g).forEach(e=>{const[h,i]=g[e].split(":");if(-1===valids.indexOf(h)&&d({[f]:{path:b,message:`${h} rule does not exist`}}),"undefined"==typeof c[f]&&-1!==g.indexOf("required")&&d({[f]:{path:b,message:validators.required({value:c[f],label:"object"==typeof a[f]?a[f].label||f:f})}}),"undefined"==typeof c[f]&&d(!1),"undefined"!=typeof c[f]){const e=validators[h]({value:c[f],label:"object"==typeof a[f]?a[f].label||f:f,valid:i,path:b,isNumber:g.indexOf("number")||g.indexOf("integer"),isRequired:-1!==g.indexOf("required")});e&&d({[f]:{path:b,message:e}})}})}),d(!1)});module.exports=hasErrors;